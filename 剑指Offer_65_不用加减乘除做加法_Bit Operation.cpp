class Solution {
public:
    int add(int a, int b) { // 本题不能用+-*/，显然就是要用位运算了。其实对于底层的数字逻辑电路，它们的加法器也是这么实现的，所以本题很有意义。
        int sum; // 和值
        int carry; // 进位值，注意：一般进位均习惯用carry表示
        do{ // 用do while 方便判断
            sum = a ^ b; // 二进制求和其实是异或的过程，比如01 + 11 = 10（不算进位项）
            carry = (unsigned int)(a & b) << 1; // unsigned int是防止负数，这样类型转换之后，剩下的交给计算机自己处理。至于负数怎么表达，查阅相关的数电资料即可。
            // 我们就来说说正数，还是上面的例子：01 & 11 = 01（按位与），之后左移一位(<<移位运算符)，变成10，这是进的位。 
            a = sum; // 用a承接sum
            b = carry; // b承接carry，之后再a与b求和：010 + 010 = 000（不算进位），之后进位100，之后再相加（异或）...... 总之，最后不再进位，就是最终结果。
        }while(carry != 0);
        return sum; // 不再进位后，得到最终sum。
    }
};

// reference 《剑指offer》